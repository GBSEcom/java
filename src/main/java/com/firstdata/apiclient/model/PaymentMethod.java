/*
 * First Data REST Payment API Specification
 * First Data REST API for payment features for 6.2.0 release
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.firstdata.apiclient.model;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModelProperty;

import java.io.IOException;
import java.util.Objects;

/**
 * PaymentMethod
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-04T17:00:16.359-05:00")
public class PaymentMethod {
    /**
     * Type of payment method. PayPal can only do &#39;Credit&#39; as primary transactions with Order. Email is mandatory. PayPal secondary transactions are processed as any other secondary transactions.
     */
    @JsonAdapter(TypeEnum.Adapter.class)
    public enum TypeEnum {
        PAYMENT_CARD("PAYMENT_CARD"),

        SEPA_DIRECT_DEBIT("SEPA_DIRECT_DEBIT");

        private final String value;

        TypeEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static TypeEnum fromValue(String text) {
            for (TypeEnum b : TypeEnum.values()) {
                if (String.valueOf(b.value).equals(text)) {
                    return b;
                }
            }
            return null;
        }

        public static class Adapter extends TypeAdapter<TypeEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public TypeEnum read(final JsonReader jsonReader) throws IOException {
                String value = jsonReader.nextString();
                return TypeEnum.fromValue(String.valueOf(value));
            }
        }
    }

    @SerializedName("type")
    private TypeEnum type = null;

    @SerializedName("paymentCard")
    private PaymentCard paymentCard = null;

    @SerializedName("sepaDirectDebit")
    private SepaDirectDebit sepaDirectDebit = null;

    @SerializedName("applePay")
    private ApplePay applePay = null;

    public PaymentMethod type(TypeEnum type) {
        this.type = type;
        return this;
    }

    /**
     * Type of payment method. PayPal can only do &#39;Credit&#39; as primary transactions with Order. Email is mandatory. PayPal secondary transactions are processed as any other secondary transactions.
     *
     * @return type
     **/
    @ApiModelProperty(required = true, value = "Type of payment method. PayPal can only do 'Credit' as primary transactions with Order. Email is mandatory. PayPal secondary transactions are processed as any other secondary transactions. ")
    public TypeEnum getType() {
        return type;
    }

    public void setType(TypeEnum type) {
        this.type = type;
    }

    public PaymentMethod paymentCard(PaymentCard paymentCard) {
        this.paymentCard = paymentCard;
        return this;
    }

    /**
     * Get paymentCard
     *
     * @return paymentCard
     **/
    @ApiModelProperty(value = "")
    public PaymentCard getPaymentCard() {
        return paymentCard;
    }

    public void setPaymentCard(PaymentCard paymentCard) {
        this.paymentCard = paymentCard;
    }

    public PaymentMethod sepaDirectDebit(SepaDirectDebit sepaDirectDebit) {
        this.sepaDirectDebit = sepaDirectDebit;
        return this;
    }

    /**
     * Get sepaDirectDebit
     *
     * @return sepaDirectDebit
     **/
    @ApiModelProperty(value = "")
    public SepaDirectDebit getSepaDirectDebit() {
        return sepaDirectDebit;
    }

    public void setSepaDirectDebit(SepaDirectDebit sepaDirectDebit) {
        this.sepaDirectDebit = sepaDirectDebit;
    }

    public PaymentMethod applePay(ApplePay applePay) {
        this.applePay = applePay;
        return this;
    }

    /**
     * Get applePay
     *
     * @return applePay
     **/
    @ApiModelProperty(value = "")
    public ApplePay getApplePay() {
        return applePay;
    }

    public void setApplePay(ApplePay applePay) {
        this.applePay = applePay;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PaymentMethod paymentMethod = (PaymentMethod) o;
        return Objects.equals(this.type, paymentMethod.type) &&
                Objects.equals(this.paymentCard, paymentMethod.paymentCard) &&
                Objects.equals(this.sepaDirectDebit, paymentMethod.sepaDirectDebit) &&
                Objects.equals(this.applePay, paymentMethod.applePay);
    }

    @Override
    public int hashCode() {
        return Objects.hash(type, paymentCard, sepaDirectDebit, applePay);
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class PaymentMethod {\n");

        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("    paymentCard: ").append(toIndentedString(paymentCard)).append("\n");
        sb.append("    sepaDirectDebit: ").append(toIndentedString(sepaDirectDebit)).append("\n");
        sb.append("    applePay: ").append(toIndentedString(applePay)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

